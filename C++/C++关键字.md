# 1. static 静态变量
### 在C++中，类内数据成员可以定义为static
- 对于非静态数据成员，每个对象有一个副本。而静态数据成员是类的成员，只存在一个副本，被所有对象共享。
- 静态成员变量没有实例化对象也可以使用，“类名：静态成员变量”
- 静态成员变量初始化在类外，但是private和protected修饰的静态成员不能类外访问。
- 在类中，static修饰的函数是静态成员函数。静态成员函数一样属于类，不属于对象，被对象共享。静态成员函数没有this指针，不能访问非静态的函数和变量，只能访问静态的。

### 与全局变量相比，静态数据成员的优势：
- 全局变量作用域是整个工程，而static作用域是当前文件，*避免命名冲突*
- 静态数据成员可以是private成员，而全局变量不能，*实现信息隐藏*

### 为什么静态成员变量不能在类内初始化？
因为类的声明可能会在多处引用，每次引用都会初始化一次，分配一次空间。这和静态变量只能初始化一次，只有一个副本冲突，因此静态成员变量只能类外初始化。

### 为什么static静态变量只能初始化一次？
所有变量都只初始化一次。但是静态变量在全局区（静态区），而自动变量在栈区。静态变量生命周期和程序一样，只创建初始化一次就一直存在，不会销毁。而自动变量生命周期和函数一样，函数调用就进行创建初始化，函数结束就销毁，所以每一次调用函数就初始化一次。

### 在头文件中定义静态变量是否可行？
不可行，在头文件中定义的一个static变量，对于包含该头文件的所有源文件，实质上在每个源文件内定义了一个同名的static变量。造成资源浪费，可能引起bug


# 2. const 常量类型
- 常量定义时，必须初始化
- 修饰函数的参数，函数体内不能修改这个参数的值
- 修饰函数的返回值
    - const修饰的返回值类型为指针，返回的指针不能被修改，而且只能符给被const修饰的指针
    - const修饰的返回值类型为引用，那么函数调用表达式不能做左值（函数不能被赋值）
    - const修饰的返回值类型为普通变量，由于返回是普通临时变量，const修饰没意义。

### 在c++中，const还有作用为：
- const修饰类内的数据成员。表示这个数据成员在某个对象的生命周期是常量，不同对象的值可以不一样，因此const成员函数不能在类内初始化。
- const修饰类内的成员函数。那么这个函数就不能修改对象的成员变量

### const修饰指针的区别
```cpp
const int *p;
// p 是一个指向 int 类型常量的指针。也就是说，指针 p 可以指向任何 int 类型的数据，但不能通过指针修改所指向的数据。
int const *p;
// int const *p; 和 const int *p; 是完全等价的。它们表示 p 是一个指向 const int 类型的指针，意味着 p 不能修改它所指向的 int 数据。
int *const p;
// p 是一个常量指针，意味着 p 一旦被初始化之后，它不能指向其他位置，但可以通过 p 修改所指向的数据。
const int *const p;
// p 是一个常量指针，且指向的是常量数据。意味着 p 不能指向其他位置，也不能修改所指向的数据。
```

#### 不考虑类的情况
- const常量在定义时必须初始化，之后无法更改
- const形参可以接收const和非const类型的实参，例如// i 可以是 int 型或者 const int 型void fun(const int& i){ //…}

#### 考虑类的情况
- const成员变量：不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且必须有构造函数；不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化
- const成员函数：const对象不可以调用非const成员函数；非const对象都可以调用；不可以改变非mutable（用该关键字声明的变量可以在const成员函数中被修改）数据的值

