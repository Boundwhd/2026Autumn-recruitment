# 1. static 静态变量
### 在C++中，类内数据成员可以定义为static
- 对于非静态数据成员，每个对象有一个副本。而静态数据成员是类的成员，只存在一个副本，被所有对象共享。
- 静态成员变量没有实例化对象也可以使用，“类名：静态成员变量”
- 静态成员变量初始化在类外，但是private和protected修饰的静态成员不能类外访问。
- 在类中，static修饰的函数是静态成员函数。静态成员函数一样属于类，不属于对象，被对象共享。静态成员函数没有this指针，不能访问非静态的函数和变量，只能访问静态的。

### 与全局变量相比，静态数据成员的优势：
- 全局变量作用域是整个工程，而static作用域是当前文件，*避免命名冲突*
- 静态数据成员可以是private成员，而全局变量不能，*实现信息隐藏*

### 为什么静态成员变量不能在类内初始化？
因为类的声明可能会在多处引用，每次引用都会初始化一次，分配一次空间。这和静态变量只能初始化一次，只有一个副本冲突，因此静态成员变量只能类外初始化。

### 为什么static静态变量只能初始化一次？
所有变量都只初始化一次。但是静态变量在全局区（静态区），而自动变量在栈区。静态变量生命周期和程序一样，只创建初始化一次就一直存在，不会销毁。而自动变量生命周期和函数一样，函数调用就进行创建初始化，函数结束就销毁，所以每一次调用函数就初始化一次。

### 在头文件中定义静态变量是否可行？
不可行，在头文件中定义的一个static变量，对于包含该头文件的所有源文件，实质上在每个源文件内定义了一个同名的static变量。造成资源浪费，可能引起bug


# 2. const 常量类型
- 常量定义时，必须初始化
- 修饰函数的参数，函数体内不能修改这个参数的值
- 修饰函数的返回值
    - const修饰的返回值类型为指针，返回的指针不能被修改，而且只能符给被const修饰的指针
    - const修饰的返回值类型为引用，那么函数调用表达式不能做左值（函数不能被赋值）
    - const修饰的返回值类型为普通变量，由于返回是普通临时变量，const修饰没意义。

### 在c++中，const还有作用为：
- const修饰类内的数据成员。表示这个数据成员在某个对象的生命周期是常量，不同对象的值可以不一样，因此const成员函数不能在类内初始化。
- const修饰类内的成员函数。那么这个函数就不能修改对象的成员变量

### const修饰指针的区别
```cpp
const int *p;
// p 是一个指向 int 类型常量的指针。也就是说，指针 p 可以指向任何 int 类型的数据，但不能通过指针修改所指向的数据。
int const *p;
// int const *p; 和 const int *p; 是完全等价的。它们表示 p 是一个指向 const int 类型的指针，意味着 p 不能修改它所指向的 int 数据。
int *const p;
// p 是一个常量指针，意味着 p 一旦被初始化之后，它不能指向其他位置，但可以通过 p 修改所指向的数据。
const int *const p;
// p 是一个常量指针，且指向的是常量数据。意味着 p 不能指向其他位置，也不能修改所指向的数据。
```

#### 不考虑类的情况
- const常量在定义时必须初始化，之后无法更改
- const形参可以接收const和非const类型的实参，例如// i 可以是 int 型或者 const int 型void fun(const int& i){ //…}

#### 考虑类的情况
- const成员变量：不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且必须有构造函数；不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化
- const成员函数：const对象不可以调用非const成员函数；非const对象都可以调用；不可以改变非mutable（用该关键字声明的变量可以在const成员函数中被修改）数据的值


# volatile
volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。
保证程序在访问 volatile 变量时，每次都直接从内存中读取，而不是从寄存器或缓存中读取优化后的值。

- 编译器不再进行优化，从而可以提供对特殊地址的稳定访问。
- 系统总是重新从它所在的内存读取数据，不会利用cache中原有的数值。
- 用于多线程被多个任务共享的变量，或者并行设备的硬件寄存器

### volatile关键字的两层语义

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：

1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。

2）禁止进行指令重排序。


# 枚举类型 enum
在 C++ 中，枚举（enum）是一种用户定义的数据类型，用于表示一组具名的整数常量。它为代码提供了更好的可读性和维护性，适用于定义固定范围的值。

C++11 引入了 强类型枚举（enum class），它与普通枚举（也叫弱类型枚举）有以下几个区别：

- 作用域限制：
强类型枚举是有作用域的，枚举成员名不会直接暴露到外部作用域。
- 类型安全：
强类型枚举不能隐式转换为整数或其他类型。

# 参考文章：
https://blog.csdn.net/qq_44814825/article/details/128525379